# Deep Agents UI - GitHub Copilot Instructions

## Project Overview
Deep Agents UI is a React-based frontend application for interacting with LangChain's Deep Agents - AI agents capable of handling tasks of varying complexity. This application provides a chat interface, task management, file handling, and real-time agent monitoring capabilities.

## Technology Stack

### Core Technologies
- **React 19.1.0** - Modern React with latest features
- **TypeScript** - Full type safety throughout the application
- **Vite 6.x** - Fast build tool and dev server
- **Node.js** - Runtime environment

### Styling & UI
- **Tailwind CSS 3.4** - Utility-first CSS framework
- **SCSS Modules** - Component-scoped styling with CSS modules
- **shadcn/ui** - High-quality component library built on Radix UI
- **Radix UI** - Headless UI primitives for accessibility
- **Lucide React** - Icon library

### Key Dependencies
- **@langchain/langgraph-sdk** - LangGraph integration for AI agents
- **react-markdown** - Markdown rendering with syntax highlighting
- **react-syntax-highlighter** - Code syntax highlighting
- **nuqs** - URL state management
- **uuid** - Unique identifier generation

## Project Structure

```
src/
├── App.tsx                    # Main application component
├── main.tsx                   # Application entry point
├── vite-env.d.ts             # Vite type declarations
├── app/                      # Main application code
│   ├── components/           # React components
│   │   ├── ChatInterface/    # Chat UI and message handling
│   │   ├── ChatMessage/      # Individual message components
│   │   ├── SubAgentPanel/    # Sub-agent detail panel
│   │   ├── TasksFilesSidebar/# Task and file management
│   │   └── ...              # Other feature components
│   ├── hooks/               # Custom React hooks
│   ├── styles/              # Global SCSS styles and variables
│   │   ├── _variables.scss  # Design tokens and theme variables
│   │   └── globals.scss     # Global styles
│   ├── types/               # TypeScript type definitions
│   └── utils/               # Utility functions
├── components/              # Shared UI components
│   └── ui/                 # shadcn/ui components
├── lib/                    # Library code and utilities
│   ├── client.ts           # LangGraph client setup
│   └── utils.ts            # Common utilities
└── providers/              # React context providers
    └── Auth.tsx           # Authentication context
```

## Development Workflow

### Build System
- **Development**: `npm run dev` (Vite dev server on port 3000)
- **Build**: `npm run build` (TypeScript compilation + Vite build)
- **Preview**: `npm run preview` (Preview production build)
- **Lint**: `npm run lint` (ESLint with TypeScript support)

### Environment Configuration
Create `.env.local` for environment variables:
```env
VITE_DEPLOYMENT_URL="http://127.0.0.1:2024"  # LangGraph server URL
VITE_AGENT_ID="deepagent"                    # Agent identifier
VITE_LANGSMITH_API_KEY=""                    # LangSmith API key (optional)
```

## Code Patterns & Best Practices

### Component Architecture
1. **Functional Components**: Use function components with hooks
2. **TypeScript Interfaces**: Define clear props interfaces for all components
3. **React.memo**: Use for performance optimization where appropriate
4. **Custom Hooks**: Extract reusable logic into custom hooks

### Styling Approach
1. **SCSS Modules**: Use for component-specific styles (`.module.scss`)
2. **Tailwind Classes**: Use for utility styling and rapid prototyping
3. **Design Tokens**: Reference variables from `_variables.scss`
4. **shadcn/ui**: Prefer pre-built components for common UI patterns

### File Naming Conventions
- Components: `PascalCase` (e.g., `ChatMessage.tsx`)
- Hooks: `camelCase` starting with `use` (e.g., `useChat.ts`)
- Utilities: `camelCase` (e.g., `utils.ts`)
- Types: `PascalCase` interfaces (e.g., `ToolCall`, `SubAgent`)
- Styles: `ComponentName.module.scss`

### State Management
- **React State**: Use `useState` for local component state
- **URL State**: Use `nuqs` for state that should persist in URL
- **Context**: Use React Context for app-wide state (e.g., Auth)
- **Props**: Pass data down component tree explicitly

### Error Handling
- Use TypeScript for compile-time error prevention
- Implement proper error boundaries where needed
- Handle async operations with proper try-catch blocks
- Validate environment variables and provide defaults

### Performance Considerations
- Use `React.memo` for expensive components
- Implement proper dependency arrays in `useEffect`
- Lazy load components when appropriate
- Optimize bundle size with proper imports

## Component Patterns

### Typical Component Structure
```typescript
import React from 'react';
import styles from './ComponentName.module.scss';

interface ComponentNameProps {
  // Define clear prop types
  data: SomeType;
  onAction: (param: string) => void;
  optional?: boolean;
}

export const ComponentName = React.memo<ComponentNameProps>(({
  data,
  onAction,
  optional = false
}) => {
  // Component logic here
  
  return (
    <div className={styles.container}>
      {/* Component JSX */}
    </div>
  );
});

ComponentName.displayName = 'ComponentName';
```

### Custom Hook Pattern
```typescript
import { useState, useEffect } from 'react';

export const useCustomHook = (param: string) => {
  const [state, setState] = useState<Type>(initialValue);
  
  useEffect(() => {
    // Effect logic
  }, [param]);
  
  return { state, setState };
};
```

## AI Agent Integration

### Key Concepts
- **Messages**: Chat messages between user and agents
- **ToolCalls**: Function calls made by agents
- **SubAgents**: Specialized agents for specific tasks
- **Threads**: Conversation sessions with unique IDs

### LangGraph Client Usage
```typescript
import { Client } from '@langchain/langgraph-sdk';

// Initialize client with environment configuration
const client = new Client({
  apiUrl: import.meta.env.VITE_DEPLOYMENT_URL,
});
```

## Testing Approach
- Focus on component behavior rather than implementation
- Test user interactions and state changes
- Mock external dependencies (LangGraph SDK calls)
- Test error states and edge cases

## Deployment
- **Development**: Local Vite dev server
- **Production**: AWS Amplify with `amplify.yml` configuration
- **Build Output**: Static files in `dist/` directory
- **Environment Variables**: Set in deployment platform

## Common Tasks

### Adding a New Component
1. Create component file in appropriate directory
2. Define TypeScript interfaces for props
3. Implement component with proper patterns
4. Add corresponding SCSS module if needed
5. Export from index file if creating a module

### Styling a Component
1. Create `.module.scss` file alongside component
2. Import design tokens from `_variables.scss`
3. Use Tailwind utilities for common styles
4. Implement responsive design with mobile-first approach

### Integrating with Agents
1. Use existing patterns from `ChatInterface` and `useChat`
2. Handle async operations properly
3. Implement loading states and error handling
4. Follow the established message/toolCall patterns

## Important Notes
- Always use TypeScript - no `any` types
- Follow React 19 patterns and best practices  
- Maintain consistent code formatting with Prettier
- Use semantic HTML and ensure accessibility
- Test components thoroughly before committing
- Keep bundle size optimized
- Follow existing patterns for consistency